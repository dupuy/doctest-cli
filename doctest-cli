#!/usr/bin/env python

from __future__ import print_function
from argparse import ArgumentParser
import subprocess as sp

cmd_prefix = '>>>'
comment_prefix = '#'
stderr_prefix = '!'
returncode_prefix = '$?='

class Tester():

    def __init__(self, file):
        self.cmd = []
        self.stdout = []
        self.stderr = []
        self.returncode = []
        self.parse_file(file)

    def add_cmd(self, cmd):
        self.cmd.append(cmd)
        self.stdout.append([])
        self.stderr.append([])
        self.returncode.append(0)

    def add_stdout(self, line):
        self.stdout[len(self.cmd)-1].append(line)

    def add_stderr(self, line):
        self.stderr[len(self.cmd)-1].append(line)

    def add_returncode(self, retc):
        self.returncode[len(self.cmd)-1] = retc

    def parse_file(self, file):
        with open(args.file) as file:
            for line in file:
                line = line.strip()
                if line.startswith(comment_prefix) or len(line) is 0:
                    continue
                elif line.startswith(cmd_prefix):
                    cmd = line.strip(cmd_prefix).strip()
                    self.add_cmd(cmd)
                elif line.startswith(returncode_prefix):
                    returncode = int(line.strip(returncode_prefix).strip())
                    self.add_returncode(returncode)
                elif line.startswith(stderr_prefix):
                    self.add_stderr(line.strip(stderr_prefix).strip())
                else:
                    self.add_stdout(line)

    def test(self):
        passed = 0
        failed = 0
        for i,cmd in enumerate(self.cmd):
            exp_out = self.stdout[i] if len(self.stdout[i]) > 0 else ['']
            exp_err = self.stderr[i] if len(self.stderr[i]) > 0 else ['']
            exp_ret = self.returncode[i]

            p = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
            out, err = p.communicate()
            out = out.decode('utf-8').strip().split('\n')
            err = err.decode('utf-8').strip().split('\n')
            ret = p.returncode

            if out == exp_out and ret == exp_ret and err == exp_err:
                passed += 1
            elif ret != exp_ret:
                failed += 1
                print('Error while running:')
                print(' ', cmd)
                print('With STDERR:')
                print(' ', '\n'.join(err))
                print('Expected return code:', exp_ret)
                print('Got:', ret)
            elif err != exp_err:
                failed += 1
                print('Error while running:')
                print(' ', cmd)
                print('Expected STDERR:')
                print(' ', '\n'.join(exp_err))
                print('Got:')
                print(' ', '\n'.join(err))
            else:
                failed += 1
                print('Error while running:')
                print(' ', cmd)
                print('With STDERR:')
                print(' ', '\n'.join(err))
                print('Expected STDOUT:')
                print(' ', '\n'.join(exp_out))
                print('Got:')
                print(' ', '\n'.join(out))

        return (passed, failed)

if __name__ == '__main__':
    parser = ArgumentParser('doctest-cli')
    parser.add_argument('file', help='input file')
    args = parser.parse_args()

    t = Tester(args.file)
    passed, failed = t.test()
    print('\nTests passed: {}\nTests failed: {}'.format(passed, failed))
